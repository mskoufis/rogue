

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Sending Frames &mdash; Rogue v3.7.0-269-ged63acb3 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Receiving Frames" href="receiving.html" />
    <link rel="prev" title="Connecting Streams" href="connecting.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Rogue
          

          
          </a>

          
            
            
              <div class="version">
                v3.7.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Interfaces</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Stream Interface</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="connecting.html">Connecting Streams</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Sending Frames</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#python-master-subclass">Python Master Subclass</a></li>
<li class="toctree-l4"><a class="reference internal" href="#c-master-subclass">C++ Master Subclass</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="receiving.html">Receiving Frames</a></li>
<li class="toctree-l3"><a class="reference internal" href="usingTcp.html">Using The TCP Bridge</a></li>
<li class="toctree-l3"><a class="reference internal" href="usingFifo.html">Using A Fifo</a></li>
<li class="toctree-l3"><a class="reference internal" href="usingFilter.html">Using A Filter</a></li>
<li class="toctree-l3"><a class="reference internal" href="debugStreams.html">Debugging Streams</a></li>
<li class="toctree-l3"><a class="reference internal" href="classes/index.html">Stream Interface Class Descriptions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../memory/index.html">Memory Interface</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../hardware/index.html">Hardware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../logging/index.html">Logging In Rogue</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../custom_module/index.html">Creating Custom Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installing/index.html">Installing &amp; Compiling Rogue</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Rogue</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Interfaces</a> &raquo;</li>
        
          <li><a href="index.html">Stream Interface</a> &raquo;</li>
        
      <li>Sending Frames</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/interfaces/stream/sending.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="sending-frames">
<span id="interfaces-stream-sending"></span><h1>Sending Frames<a class="headerlink" href="#sending-frames" title="Permalink to this headline">¶</a></h1>
<p>Frames are transmitted by a subclass of the <a class="reference internal" href="classes/master.html#interfaces-stream-master"><span class="std std-ref">Master</span></a> class in rogue.
This subclass can be created either in python or in c++. In order to send a Frame, the
master sub-class must first request the creation of a new Frame with enough space available for
the intended payload. This is done by generating a Frame request to the primary slave with two
parameters: the Frame size and a zero copy enable flag. In most cases the implementer will
want to set the zero copy flag to True, allowing the primary slave to determine if it will
use zero copy buffers for the new Frame. If the master intends to re-use the Frame, i.e. sending it
multiple times, it will want to disallow the creation of zero copy buffers. A Frame with
zero copy buffers is usually emptied when it is passed to the primary slave and cannot be
reused.</p>
<p>Python and C++ subclasses of the Master class can be used interchagably, allowing c++ subclasses
to receive Frames from python masters and python subclasses to receive Frames from c++ masters.</p>
<div class="section" id="python-master-subclass">
<h2>Python Master Subclass<a class="headerlink" href="#python-master-subclass" title="Permalink to this headline">¶</a></h2>
<p>Implementing a Master subclass in python is easy, but may result in a lower level of performance.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">rogue.interfaces.stream</span>

<span class="k">class</span> <span class="nc">MyCustomMaster</span><span class="p">(</span><span class="n">rogue</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">Master</span><span class="p">):</span>

    <span class="c1"># Init method must call the parent class init</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="c1"># Method for generating a frame</span>
    <span class="k">def</span> <span class="nf">myFrameGen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># First request an empty from from the primary slave</span>
        <span class="c1"># The first arg is the size, the second arg is a boolean</span>
        <span class="c1"># indicating if we can allow zero copy buffers, usually set to true</span>

        <span class="c1"># Here we request a frame capable of holding 100 bytes</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reqFrame</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

        <span class="c1"># Create a 10 byte array with an incrementing value</span>
        <span class="n">ba</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)])</span>

        <span class="c1"># Write the data to the frame at offset 0</span>
        <span class="c1"># The payload size of the frame is automatically updated</span>
        <span class="c1"># to the highest index which as written to.</span>
        <span class="c1"># A lock is not required because we are the only instance</span>
        <span class="c1"># which knows about this frame at this point</span>

        <span class="c1"># The frame will now have a payload size of 10</span>
        <span class="n">frame</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># The user may also write to an arbitrary offset, the valid payload</span>
        <span class="c1"># size of the frame is set to the highest index written.</span>
        <span class="c1"># Locations not explicity written, but below the highest written</span>
        <span class="c1"># index, will be considered valid, but may contain random data</span>
        <span class="n">ba</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">([</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">10</span><span class="p">)])</span>
        <span class="n">frame</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span><span class="mi">50</span><span class="p">)</span>

        <span class="c1"># At this point locations 0 - 9 and 50 - 59 contain known values</span>
        <span class="c1"># The new payload size is now 60, but locations 10 - 49 may</span>
        <span class="c1"># contain random data</span>

        <span class="c1"># Send the frame to the currently attached slaves</span>
        <span class="c1"># The method returns once all the slaves have received the</span>
        <span class="c1"># frame and their acceptFrame methods have returned</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sendFrame</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="c-master-subclass">
<h2>C++ Master Subclass<a class="headerlink" href="#c-master-subclass" title="Permalink to this headline">¶</a></h2>
<p>Creating a Master sub-class in c++ is done in a similiar fashion. A new frame is
requested just as it is in python and the sendFrame() method is used to pass the
frame to the connected Slaves. The main difference is that accessing the Frame
data can be done more directly using an interator.</p>
<p>In order to use a custom c++ Master subclass, you will need to build it into a c++ python module or into
a c++ application. See the sections <a class="reference internal" href="../../custom_module/index.html#custom-module"><span class="std std-ref">Creating Custom Modules</span></a> and <a class="reference internal" href="../../installing/application.html#installing-application"><span class="std std-ref">Compiling A Rogue Application</span></a>.</p>
<p>The example below shows the most direct method for updating data within a frame using
an iterator. Here we both de-reference the iterator directly to update specific locations
and we use std::copy to move data from data buffer into the Frame.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#import &lt;rogue/interfaces/stream/Master.h&gt;</span>
<span class="cp">#import &lt;rogue/interfaces/stream/Frame.h&gt;</span>
<span class="cp">#import &lt;rogue/interfaces/stream/FrameIterator.h&gt;</span>

<span class="n">class</span> <span class="nl">MyCustomMaster</span> <span class="p">:</span> <span class="n">public</span> <span class="n">rogue</span><span class="o">::</span><span class="n">interfaces</span><span class="o">::</span><span class="n">stream</span><span class="o">::</span><span class="n">Master</span> <span class="p">{</span>
   <span class="nl">public</span><span class="p">:</span>

      <span class="c1">// Create a static class creator to return our custom class</span>
      <span class="c1">// wrapped with a shared pointer</span>
      <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">MyCustomMaster</span><span class="o">&gt;</span> <span class="n">create</span><span class="p">()</span> <span class="p">{</span>
         <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">MyCustomMaster</span><span class="o">&gt;</span> <span class="n">ret</span> <span class="o">=</span>
            <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">MyCustomMaster</span><span class="o">&gt;</span><span class="p">();</span>
         <span class="k">return</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="c1">// Standard class creator which is called by create</span>
      <span class="n">MyCustomMaster</span><span class="p">()</span> <span class="o">:</span> <span class="n">rogue</span><span class="o">::</span><span class="n">interfaces</span><span class="o">::</span><span class="n">stream</span><span class="o">::</span><span class="n">Master</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

      <span class="kt">void</span> <span class="n">myFrameGen</span><span class="p">()</span> <span class="p">{</span>
         <span class="n">rogue</span><span class="o">::</span><span class="n">interfaces</span><span class="o">::</span><span class="n">stream</span><span class="o">::</span><span class="n">FramePtr</span> <span class="n">frame</span><span class="p">;</span>
         <span class="n">rogue</span><span class="o">::</span><span class="n">interfaces</span><span class="o">::</span><span class="n">stream</span><span class="o">::</span><span class="n">FrameIterator</span> <span class="n">it</span><span class="p">;</span>
         <span class="kt">uint32_t</span> <span class="n">x</span><span class="p">;</span>

         <span class="c1">// First request an empty from from the primary slave</span>
         <span class="c1">// The first arg is the size, the second arg is a boolean</span>
         <span class="c1">// indicating if we can allow zero copy buffers, usually set to true</span>

         <span class="c1">// Here we request a frame capable of holding 100 bytes</span>
         <span class="n">frame</span> <span class="o">=</span> <span class="n">reqFrame</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span>

         <span class="c1">// Here we get an iterator to the frame data in write mode</span>
         <span class="n">it</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">beginWrite</span><span class="p">();</span>

         <span class="c1">// Set an incrementing value to the first 10 locations</span>
         <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
            <span class="n">it</span><span class="o">++</span><span class="p">;</span>
         <span class="p">}</span>

         <span class="c1">// Use std::copy to copy data from a data buffer</span>
         <span class="c1">// Here we copy 10 bytes starting a the current position of 10</span>
         <span class="c1">// Update the iterator</span>
         <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="o">+</span><span class="mi">10</span><span class="p">,</span> <span class="n">it</span><span class="p">);</span>

         <span class="c1">// Unlink the python API we must now specify the new payload size</span>
         <span class="n">frame</span><span class="o">-&gt;</span><span class="n">setPayload</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>

         <span class="c1">//Send frame</span>
         <span class="n">sendFrame</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
      <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Shared pointer alias</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">MyCustomMaster</span><span class="o">&gt;</span> <span class="n">MyCustomMasterPtr</span><span class="p">;</span>
</pre></div>
</div>
<p>The std::copy call works very well for moving data between two standard C++ iterators. It will
properly deal with iterators which manage non-contigous buffers, which may be the case when allocating
new Frames. For example when sending large data frames over a UDP interface, the Slave which allocates the
buffer may create a Frame consistaing up a number of 1500 byte frames which may exist at random locations
in memory. If we are to use std::copy in this case, it will detect that the passed iterator range is non-contigous, and default to a less performant method of copying data byte by byte.</p>
<p>In order to ensure the best possible performance, the Rogue <a class="reference internal" href="classes/frameIterator.html#interfaces-stream-frame-iterator"><span class="std std-ref">Frame Iterator</span></a> provides
mechanisms for iterating through each contigous buffer. The following example performs a data copy from
a passed data buffer into the Rogue frame, ensuring that the most effeciant copy methods are used:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span>  <span class="n">size</span><span class="p">;</span>
<span class="kt">uint8_t</span> <span class="o">*</span> <span class="n">data</span><span class="p">;</span>

<span class="c1">// Request a new buffer with 100 bytes</span>
<span class="n">frame</span> <span class="o">=</span> <span class="n">reqFrame</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span>

<span class="c1">// Get an iterator to the start of the Frame</span>
<span class="n">it</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">beginWrite</span><span class="p">();</span>

<span class="c1">// Keep going until we get to the end of the Frame, assume the passed data pointer has 100 bytes</span>
<span class="k">while</span> <span class="p">(</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">endWrite</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>

   <span class="c1">// The rem buffer method returns the number of bytes left in the current contigous buffer</span>
   <span class="n">size</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">remBuffer</span><span class="p">();</span>

   <span class="c1">// Copy size number of bytes, updating both pointers</span>
   <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="o">+</span><span class="n">size</span><span class="p">;</span> <span class="n">it</span><span class="p">);</span>
   <span class="n">data</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Remember to update the new payload size</span>
<span class="n">frame</span><span class="o">-&gt;</span><span class="n">setPayload</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</pre></div>
</div>
<p>Alternatively if the user wishes to access individual values in the data frame at various offsets,
they can make use of the toFrame helper function defined in <a class="reference internal" href="classes/helpers.html#interfaces-stream-helpers"><span class="std std-ref">Frame Helpers</span></a>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint64_t</span> <span class="n">data64</span><span class="p">;</span>
<span class="kt">uint32_t</span> <span class="n">data32</span><span class="p">;</span>
<span class="kt">uint8_t</span>  <span class="n">data8</span><span class="p">;</span>

<span class="n">it</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">beginWrite</span><span class="p">();</span>

<span class="c1">// Write 64-bits and advance iterator 8 bytes</span>
<span class="n">toFrame</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data64</span><span class="p">);</span>

<span class="c1">// Write 32-bits and advance iterator 4 bytes</span>
<span class="n">toFrame</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data32</span><span class="p">);</span>

<span class="c1">// Write 8-bits and advance iterator 1 byte</span>
<span class="n">toFrame</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data8</span><span class="p">);</span>

<span class="c1">// Update frame payload size</span>
<span class="n">frame</span><span class="o">-&gt;</span><span class="n">setPayload</span><span class="p">(</span><span class="mi">13</span><span class="p">);</span>
</pre></div>
</div>
<p>Further study of the <a class="reference internal" href="classes/frame.html#interfaces-stream-frame"><span class="std std-ref">Frame</span></a> and <a class="reference internal" href="classes/buffer.html#interfaces-stream-buffer"><span class="std std-ref">Buffer</span></a> APIs will reveal more
advanced methods of access frame and buffer data.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="receiving.html" class="btn btn-neutral float-right" title="Receiving Frames" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="connecting.html" class="btn btn-neutral float-left" title="Connecting Streams" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, SLAC National Accelerator Laboratory

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>